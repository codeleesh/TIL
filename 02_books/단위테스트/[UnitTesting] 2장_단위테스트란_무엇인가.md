# [Unit Testing] 2장 단위 테스트란 무엇인가

이 내용은 ` 단위 테스트 생산성과 품질을 위한 단위 테스트 원칙과 패턴` 를 읽으면서 정리한 내용을 포함하고 있습니다.



단위테스트에 접근하는 방법에 대해서 두 가지의 뚜렷한 견해로 나뉘게 되었습니다. 각각 `고전파` 와 `런던파` 로 알려져 있습니다. 자세한 내용을 알아보도록 하겠습니다.



## 단위테스트의 정의

단위테스트는 3가지 주요 속성이 있습니다.

- 작은 코드 조각을 검증하고
- 빠르게 수행하며
- 격리된 방식으로 처리하는 자동화된 테스트



3번째 속성인 격리 문제에 대해서 단위테스트의 고전파와 런던파를 구분할 수 있게 나뉘게 됩니다.

그럼, 코드 조각을 격리된 방식으로 검증한다는 것은 무엇을 의미하는 것일까? 각 분파의 특성을 먼저 알아본 후 예제 소스도 같이 알아보도록 하겠습니다.



### 격리 문제에 대한 각 접근 방법

단위테스트 정의 중 세번째 코드 조각을 격리된 방식으로 검증한다는 속성으로 인하여 논란이 생기게 되었고 크게 2가지 파로 나뉘게 되었습니다.



#### 고전파의 접근

고전파에서는 코드를 꼭 격리하는 방식으로 테스트해야 하는 것은 아닙니다. 대신 단위 테스트는 서로 격리해서 실행해야 합니다. 이렇게 하면 테스트를 어떤 순서로든 가장 적합한 방식으로 실행할 수 있으며 서로의 결과에 영향을 미치지 않습니다. 즉, 순서와 상관없이 각 단위 테스트는 동일한 결과를 보장해야 합니다.

각각의 테스트를 격리하는 것은 여러 클래스가 모두 메모리에 상주하고 공유 상태에 도달하지 않는 한, 여러 클래스를 한 번에 테스트해도 괜찮다는 뜻입니다. 이를 통해 테스트가 서로 소통하고 실행 컨텍스트에 영향을 줄 수 있습니다. 데이터베이스, 파일 시스템 등 프로세스 외부 의존성이 이러한 공유 상태의 대표적인 예입니다.



#### 런던파의 접근

런던파에서는 테스트 대상 시스템을 협력자에게서 격리하는 것을 말합니다. 즉 하나의 클래스가 다른 클래스 또는 여러 클래스에 의존하면 이 모든 의존성을 테스트 대역으로 대체해야 합니다. 특징은 다음과 같습니다.

- 동작을 외부 영향과 분리해서 테스트 대상 클래스에만 집중할 수 있습니다.
- 테스트가 실패하면 코드베이스의 어느 부분이 고장 났는지 확실히 알 수 있다는 것입니다.



의존성을 가진 코드베이스를 테스트하는 것은 테스트 대역 없이는 어렵습니다. 의존하는 클래스의 수가 너무 많으면 어려운 작업이 됩니다. 테스트 대역을 사용하면 클래스의 직접적인 의존성을 대체할 수 있고, 더 나아가 의존성의 의존성을 다룰 필요도 없습니다.

하지만 이러한 부분은 설계의 문제를 놓치게 할 수 있습니다. 해당 의존성을 갖는 것이 맞는지 집중해야 하지만 목의 사용으로 이 부분을 놓치게 만듭니다. 관련 내용 자세한 내용은 [@SpyBean @MockBean 의도적으로 사용하지 않기](https://jojoldu.tistory.com/320) 해당 글 참고 바랍니다.



## 단위 테스트의 런던파와 고전파

고전파와 런던파로 나눠진 원인은 격리 특성에 있다는 것을 알게 되었습니다. 런던파는 대상 시스템에서 협력자를 격리하는 것으로 보는 반면, 고전파는 단위 테스트끼리 격리하는 것으로 봅니다. 종합해보면 세 가지 주요 주제에 대해 의견 차이가 있습니다.

- 격리 요구 사항
- 테스트 대상 코드 조각(단위)의 구성 요소
- 의존성 처리



런던파와 고전파의 주요 특징을 표로 나타내면 다음과 같습니다.

|        | 격리 주체   | 단위의 크기                  | 테스트 대역 사용 대상      |
| ------ | ----------- | ---------------------------- | -------------------------- |
| 런던파 | 단위        | 단일 클래스                  | 불변 의존성 외 모든 의존성 |
| 고전파 | 단위 테스트 | 단일 클래스 또는 클래스 세트 | 공유 의존성                |



여기서 공유 의존성에 대해서 알아보도록 하겠습니다.

 

### 공유 의존성, 비공개 의존성, 프로세스 외부 의존성

#### 공유 의존성

- 테스트 간에 공유되고 서로의 결과에 영향을 미칠 수 있는 수단을 제공하는 의존성입니다.
- 예로 정적 가변 필드로 이러한 필드의 변경 사항은 동일한 프로세스 내에서 실행되는 모든 단위 테스트에서 볼 수 있습니다.
- 데이터베이스도 공유 의존성의 전형적인 예가 될 수 있습니다.



#### 비공개 의존성

- 공유하지 않는 의존성입니다.



#### 프로세스 외부 의존성

- 애플리케이션 실행 프로세스 외부에서 실행되는 의존성이며, 아직 메모리에 없는 데이터에 대한 프록시입니다.
- 공유 의존성에 해당하지만 모두 그런 것은 아닙니다.
- 예를 들어, 데이터베이스는 프로세스 외부이면서 공유 의존성입니다.
  - 각 테스트 실행 전에 도커 컨테이너로 데이터베이스를 시작하면 테스트가 더 이상 동일한 인스턴스로 작동하지 않기 때문에 프로세스 외부이면서 공유하지 않는 의존성이 됩니다.
  - 데이터베이스 환경에서는 테스트가 데이터를 변경할 수 없으므로 결과에 서로 영향을 미칠 수 없습니다.



### 개발 환경

여기서는 상점 구매 도메인에 대한 고전파와 런던파의 단위 테스트 작성에 대해서 실습을 해보도록 하겠습니다.



#### 고전파 예시

테스트는 협력자를 대체하지 않고 실제 객체를 사용합니다. 

```java
@Test
void Purchase_succeeds_when_enough_inventory() {

	Store store = new Store();
  Product shampoo = Shampoo;
	store.addInventory(shampoo, 10);
	Customer customer = new Customer();

	boolean success = customer.purchase(store, shampoo, 5);
	
	assertAll(
			() -> assertThat(success).isTrue(),
			() -> assertThat(store.findInventory(shampoo)).isEqualTo(5)
	);
}
```



#### 런던파 예시

고전파와 동일한 테스트에서 `Store` 인스턴스는 테스트 대역, 구체적으로 목으로 교체해봅니다.

```java
@Test
void Purchase_succeeds_when_enough_inventory() {

	Store storeMock = mock(Store.class);
  Customer customer = new Customer();

  when(storeMock.findInventory(any())).thenReturn(5);
  when(storeMock.saveInventory(any(), anyInt())).thenReturn(5);

  boolean success = customer.purchase(storeMock, Shampoo, 5);

  assertAll(
		() -> assertThat(success).isTrue(),
		() -> assertThat(storeMock.findInventory(Shampoo)).isEqualTo(5)
  );
}
```



#### 의존성을 다루는법

의존성은 공유되거나 비공개일 수 있습니다. 비공개 의존성은 변경 가능하거나 불변일 수 있습니다. 불변인 경우 값 객체라고 부릅니다. 예를 들어 데이터베이스는 공유 의존성이며, 내부 상태는 모든 자동화된 테스트에서 공유합니다. 

- `Customer` : 두 가지 의존성(`Store` , `Product`) 중 `Store` 만 시간에 따라 변할 수 있는 내부 상태를 포함하고 있습니다.
- `Store` : 해당 객체의 내부 값을 서로 공유하지 않으나, `purchase` 를 통해 변경이 가능하기 때문에 `변경 가능한 비공개 의존성` 입니다.
- `Product` : 해당 객체의 내부 값을 서로 공유하지 않고 변하지 않는 불변값을 사용하였기 때문에 `불변인 비공개 의존성` 입니다.



## 정리

- 단위 테스트는 단일 동작 단위를 검증하고 빠르게 수행하며 다른 테스트와 별도로 동작합니다.

- 고전파자와 런던파의 의견 차이는 단위의 대한 관점과 테스트 대상 시스템의 의존성 처리 방식에 영향을 미쳤습니다.
- 런던파 테스트의 가장 큰 문제는 테스트 대상 시스템의 세부 구현에 결합된 테스트 문제입니다.



>  테스트는 코드의 단위를 검증해서는 안됩니다. 오히려 동작의 단위, 즉 문제 영역에 의미가 있는 것, 이상적으로 비즈니스 담당자가 유용하다고 인식할 수 있는 것을 검증해야 합니다. 동작 단위를 구현하는 데 클래스가 얼마나 필요한지는 상관없습니다. 단위는 여러 클래스에 걸쳐 있거나 한 클래스에만 있을 수 있고, 심지어 아주 작은 메서드가 될 수도 있습니다.



## 참고

- [단위 테스트 : 생산성과 품질을 위한 단위 테스트 원칙과 패턴](http://www.yes24.com/Product/Goods/104084175)
- [@SpyBean @MockBean 의도적으로 사용하지 않기](https://jojoldu.tistory.com/320) 
