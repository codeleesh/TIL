# 엔티티 클래스 개발2

## 정리

- `@ManyToMany`
  - 실무에서는 거의 사용하지 않습니다.
  - 다대일, 일대다로 풀어서 사용해야 합니다.
  - 만약 사용을 해야한다면 제약 조건이 있습니다.
  - 필드 추가가 어렵습니다.
  - 중간 테이블 연결을 위해서 JoinTable을 사용해야 하며, `joinColumns`, `inverseJoinColumns`을 정의해서 사용하면 중간 테이블이 생성됩니다.
  - 절대 사용하면 안됩니다.
    - `@ManyToMany`는 편리한 것 같지만, 중간 테이블에 컬럼을 추가할 수 없습니다.
    - 세밀하게 쿼리를 실행하기 어렵기 때문에 실무에서 사용하기에는 한계가 있습니다.
    - 중간 엔티티를 만들고 `@ManyToOne`, `@OneToMany`로 매핑해서 사용해야 합니다.
    - 다대다 매핑으로 풀어내서 사용해야 합니다.
- 본인 계층 구조 만들기
  - 상점 테이블이 있다고 가정합시다.
  - 상점 테이블의 변수를 `parent`로 정하고 연관관계 주인을 설정합니다.
  - 상점 테이블을 List를 이용하여 `child`로 정하고 거울로 정합니다.
    ```Java
    @ManyToOne
    @JoinColumn(name = "parent_id")
    private Book parent;

    @OneToMany(mappedBy = "parent")
    private List<Book> child = new ArrayList<>();
    ```

- 주소값 타입(`@Embeddable`)
  - 깂 타입은 기본적으로 변경이 되게 설계하면 안됩니다. (이뮤터블?)
  - Getter만 제공해야 합니다.
  - JPA의 기본 생성자가 필요합니다. `protected`
    - JPA가 이런 제약을 두는 이유는 JPA 구현 라이브러리가 객체를 생성할 때 리플렉션 같은 기술을 사용할 수 있도록 지원해야 합니다.
  - 생성자에서 값을 모두 초기화해서 변경 불가능한 클래스를 만들어야 합니다.

## TODO

- `@Getter`, `@Setter`는 실무에서 모두 제공하지 않고, 꼭 필요한 메서드를 제공하는 것이 가장 이상적입니다.
  - 실무에서 엔티티의 데이터는 조회할 일이 너무 많아서, Getter의 경우 열어두는 것이 편리합니다.
  - Setter를 호출하면 데이터가 변하게 되는데, 막 열어둔다면 가까운 미래엔 엔티티가 도대체 언제, 왜 변경되는지 추적하기가 힘들어집니다.
  - 변경 지점이 명확하도록 변경을 위한 비즈니스 메서드를 별도로 제공하는 것이 맞습니다.
- `@Id`의 컬럼명을 `테이블_ID`로 변경하는 이유
  - 엔티티의 식별자는 `id`를 사용하고 PK 컬럼명은 `객체클래스_id`
  - 엔티티는 타입이 있기 때문에, `id` 필드만으로 쉽게 구분할 수 있습니다.
  - 테이블은 단순히 id로 해버리면 실무 관점에서 찾기가 쉽지 않고 조인도 힘들다.
    - FK가 달라지기 때문입니다.
    - FK를 맞춘다면 보기가 편할 수 있습니다.
