# Docker 서비스2

## Kubernetes (K8s)

- 컨테이너화된 워크로드와 서비스를 관리하기 위한 이식성이 있고, 확장 가능한 오픈소스 플랫폼
- 선언적 구성과 자동화를 모두 용이하게 해줌
- 구글의 15여 년에 걸친 대규모 상용 워크 로드 운영 경험을 기반으로 만들어졌으며 커뮤니티의 최고의 아이디어와 적용 사례가 결합
- 분산 시스템을 탄력적으로 실행하기 위한 프레임 워크를 제공함
- 확장 요구 사항, 장애 조치, 배포 패턴 등을 처리함
- Rancher 2.0, OpenShift(RedHat), Tectonic(CoreOS), Docker Enterprise Edition 등이 쿠버네티스를 기반으로 플랫폼을 만들어 대세임을 증명하고 있고 AWS, Google Cloud, Azure, Digital Ocean, IBM Cloud, Oracle Cloud 등에서 관리형(Managed) 서비스를 내놓음으로써 클라우드 컨테이너 시장을 평정

### 상세 설명

- 전통적인 배포 시대
  - 초기 조직은 애플리케이션을 물리 서버에서 실행
  - 하드웨어 위에 운영체제 위에 애플리케이션
- 가상화된 배포 시대
  - 단일 물리 서버의 CPU에서 여러 가상 시스템(VM)을 실행
  - 하드웨어 위에 운영체제 위에 Hypervisor 위에 VM들이 존재
- 컨테이너 개발 시대
  - 컨테이너느 VM과 유사하지만 격리 속성을 완화하여 애플리케이션 간에 운영체제(OS) 공유
  - 하드웨어 위에 운영체제 위에 Container Runtime 위에 Container들이 존재

### 쿠버네티스 제공 서비스

- 서비스 디스커버리와 로드 밸런싱
  - 쿠버네트스는 DNS 이름을 사용하거나 자체 IP 주소를 사용하여 컨테이너를 노출할 수 있음
  - 컨테이너에 대한 트래픽이 많으면, 쿠버네티스는 네트워크 트래픽을 로드밸런싱하고 배포하여 배포가 안정적으로 이루어질 수 있음
- 스토리지 오케스트레이션
  - 쿠버네티스를 사용하면 로컬 저장소, 공용 클라우드 공급자 등과 같이 원하는 저장소 시스템을 자동으로 탑재할 수 있음
- 자동화된 롤아웃과 롤백
  - 쿠버네티스를 사용하여 배포된 컨테이너의 원하는 상태를 서술할 수 있으며 현재 상태를 원하는 상태로 설정한 속도에 따라 변경할 수 있음
    - 예) 쿠버네티스를 자동화해서 배포용 새 컨테이너를 만들고, 기존 컨테이너를 제거하고, 모든 리소스를 새 컨테이너에 적용할 수 있음
- 자동화된 빈 패킹(bin packing
  - 쿠버네티스를 사용하면 각 컨테이너에 필요한 CPU 및 메모리 (RAM)의 양을 지정할 수 있음
  - 컨테이너에 자원 요청이 지정되면 쿠버네티스는 컨테이너에 대한 자원을 관리하기 위해 더 나은 결정을 내릴 수 있음
- 자동화된 복구(self-healing)
  - 쿠버네티스는 실패한 컨테이너를 다시 시작하고, 컨테이너를 교체히며, 사용자 정의 상태 검사에 응답하지 않는 컨테이너를 죽이고, 서비스 준비가 끝날 때까지 그러한 과정을 클라이언트에 보여주지 않음
- 시크릿과 구성 관리
  - 쿠버네티스를 사용하면 암호, OAuth 토큰 및 ssh 키와 같은 중요한 정보를 저장하고 관리할 수 있음
  - 컨테이너 이미지를 재구성하지 않고 스택 구성에 비밀을 노출하지 않고도 비밀 및 애플리케이션 구성을 배포 및 업데이트 할 수 있음

### 쿠버네티스 커뮤니티와 생태계

- Cloud Native Landscape
- 서비스 메시(Istio, linkerd), CI(Tekton, Spinnaker), 컨테이너 서버리스(Knative), 머신러닝(kubeflow)이 모두 쿠버네티스 환경에서 동작

### 다양한 배포 방식

- 쿠버네티스를 Deployment, StatefuleSets, DaemonSet, Job, CronJob 등 다양한 배포 방식을 지원
  - Deployment는 새로운 버전의 애플리케이션을 다양한 전략으로 무중단 배포 가능
  - StatefuleSets은 실행 순서를 보장하고 호스트 이름과 볼륨을 일정하게 사용할 수 있어 순서나 데이터가 중요한 경우에 사용 가능
  - DaemonSet 로그나 모니터링 등 모든 노드에 설치가 필요한 경우
  - Job, CronJob은 배치성 작업

### 클라우드 지원

- 쿠버네티스는 부하에 따라 자동으로 서버를 늘리는 기능(AutoScaling)이 있고 IP를 할당받아 로드밸런스로 사용 가능하며 외부 스토리지를 컨테이너 내부 디렉토리에 마운트하여 사용하는 것도 가능함
- 쿠버네티스는 Cloud Controller를 이용하여 클라우드 연동을 손쉽게 확장할 수 있음
- AWS, 구글 클라우드, 마이크로소프트 애저는 물론 수십 개의 클라우드 업체에서 모듈을 제공하여 관리자는 동일한 설정 파일을 서로 다른 클라우드에서 동일하게 사용 가능함

### 아키텍처

- architecture
- pods
- kubectl
- master
- node

### 구룩 : 쿠버네티스 설치 및 클러스터 구성

1. 시스템 패키지 업데이트, k8s 사용자 생성

- k8s 클러스터에 참여하는 모든 노드에서 시스템 패키지 업데이트를 수행
- k8s 클러스터의 Master 노드에 k8s 클러스터를 관리할 사용자를 추가

2. 도커 설치

- k8s는 k8s 서비스 및 애플리케이션을 위해 사용되는 컨테이너 실행을 위해 도커 설치
- k8s 클러스터에 참여하는 모든 노드에 도커를 설치

3. k8s 설치 - Master, Worker 노드

- k8s 클러스터 구성에 참여하는 노드 중 마스터 노드에 k8s 패키지를 설치

4. k8s 초기화 - Master 노드

- k8s 클러스터 초기화를 위해 root 계정으로 환경변수 설정 및 초기화

5. Calico Pod Network 배포하기

- CNI(Container Network Interface)는 컨테이너와 컨테이너 네트워크 구현체 사이의 표준 API
- CNI 구현체는 ACI, Weave Net, Calico 등 다양하게 지원
- 정상적으로 Calico Pod 실행 점검

6. k8s 초기화 - Worker 노드

- Master 노드에서 k8s 클러스터 초기화 후 kubeadm join 명령어를 k8s 클러스터에 조인하려는 Worker 노드에서 root 권한으로 실행

7. Pod 테스트


## Jenkins

- 소프트웨어 개발시 지속적으로 통합 서비스를 제공한느 툴
- 다수의 개발자들이 하나의 프로그램을 개발할 때 버전 충돌을 방지하기 위해 각자 작업한 애요을 공유 영역에 있는 저장소에 빈번히 업로드 함으로써 지속적 통합이 가능하도록 해줌
- 프로젝트 표준 컴파일 환경에서의 컴파일 오류 검출
- 자동화 테스트 수행
- 정적 코드 분석에 의한 코딩 규약 준수여부 체크
- 프로파일링 툴을 이용한 소스 변경에 따른 성능 변화 감시
- 결합 테스트 환경에 대한 배포 작업

### 구체적 설명

- 각종 배치 작업의 간략화
  - 데이터베이스의 구축, 애플리케이션 서버로의 Deploy, 라이브러리 릴리즈와 같이 이전에 CLI로 실행되던 작업들이 젠킨스 덕분에 웹 인터페이스로 손쉽게 가능
- Build 자동화의 확립
  - 빌드 툴의 경우 Java는 maven과 gradle이 지원, 젠킨스와 연동하여 빌드 자동화를 통해 프로젝트 진헹의 효율성 증가
- 자동화 테스트
  - 젠킨스는 Subversion이나 Git과 같은 버전관리시스템과 연동하여 코드 변경을 감지하고 자동화 테스트를 수행
- 코드 표준 준수여부 검사
  - 코드 표준 준수 여부의 검사나 정적 분석을 통한 코드 품질 검사를 빌드 내부에서 수행함으로써 기술적 부채의 감소에도 크게 기여
- 빌드 파이프라인 구성
  - 2개 이상의 모듈로 구성되는 레이어드 아키텍처가 적용된 프로젝트에는 그에 따른 빌드 파이프라인 구성

### 구축 예

## 요약

- 쿠버네티스는 컨테이너화된 워크로드와 서비스를 관리하기 위한 이식성이 있고 확장 가능한 오픈소스 플랫폼이다.
- 젠킨스는 소프트웨어 개발시 지속적으로 통합 서비스를 제공하는 도구이다.
