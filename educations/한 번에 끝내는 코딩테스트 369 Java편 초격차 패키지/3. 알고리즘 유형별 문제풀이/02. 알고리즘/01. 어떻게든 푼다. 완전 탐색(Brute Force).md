# 완전 탐색(Brute Force)

## 정답은 무조건 구하는 치트키

- 문제를 해결하기 위해 확인해애 하는 모든 경우를 전부 탐색하는 방법
- 그 중에서도 백 트래킹(Back-Tracking)을 통해야 하는 상황을 해결하기!
* 모든 코테 문제에서 기본적으로 접근해 봐야 한다. 많은 연습이 필요!

## 특징

- 부분 점수를 얻기 좋다.
- 전부 탐색하기에 시간 복잡도가 일반적으로 높다.

## 코테에 나오는 완전 탐색 종류

- N개 중 중복을 허용해서
  - M개를 순서 있게 나열하기
  - M개를 고르기
- N개 중 중복없이
  - M개를 순서 있게 나열하기
  - M개를 고르기

## 완전 탐색은 함수 정의가 50%

- 완전 탐색 문제는 재귀 함수의 정의를 통해서 구현

## 1 + A 버전

- N개 중 중복을 허용해서
  - M개를 순서 있게 나열하기

[N과 M(3)](https://www.acmicpc.net/problem/15651)

### 시간, 공간 복잡도 계산하기

- N = 4, M = 3
- 4 * 4 * 4 = 4^3
- 시간 : O(N^M) => 7^7 = 82만
- 공간 : O(M)

### 구현 스케치

- 입력받은 변수 N, M
- 저장할 배열 selected
- 재귀함수
  - 만약 M 개를 전부 고름 => 조건에 맞는 탐색을 한 가지 성공한 것!
    - 배열이 새롭게 탐색된 결과
  - 아직 M 개를 고르지 않음 => k 번째부터 M 번째 원소를 조건에 맞게 고르는 모든 방법을 시도한다.
    - 1~N 까지를 k 번 원소로 한 번씩 정하고,
    - 매번 k+1 번부터 M 번 원소로 재귀호출 해주기

## 2 + A 버전

- N개 중 중복없이
  - M개를 순서 있게 나열하기

[N과 M (1)](https://www.acmicpc.net/problem/15649)

### 직접 그려보기

N = 4, M = 3

1 2 3
1 2 4
1 3 2
1 3 4
...
4 3 1

### 시간, 공간 복잡도 계산하기

- 4 * 3 * 2 = 4!

- 시간 : O(N! / (N-M)!) => 8! / 0! = 40,320
- 공간 : O(M) -> M개의 숫자를 저장하기 때문에


## 1 + B 버전

- N개 중 중복을 허용해서
  - M개를 고르기

[N과 M (3)](https://www.acmicpc.net/problem/15652)

### 직접 그려보기

N = 4, M = 3

1 1 1
2 2 3
2 1 2 (X)
4 4 4

### 시간, 공간 복잡도 계산하기

- 4 * 4 * 4 = 4^3 보단 작다.
- 시간 : O(N^M) => 8^8 = 1677만 보단 작다.
- 공간 : O(M)

### 구현

- cand의 가능한 숫자의 시작을 지정
  - start는 이전 숫자인 k-1보다 크거나 같아야함
- 만약 start가 0이면 1로 변경
  - 1부터 N까지 작성하기 때문

## 2 + B 버전

- N개 중 중복없이
  - M개를 고르기

[N과 M (2)](https://www.acmicpc.net/problem/15650)

### 직접 그려보기

N = 4, M = 3

1 2 3
1 2 4
1 3 4
2 3 4
3 4 X

### 시간, 공간 복잡도 계산하기

- 시간 : O(N! / M!(N-M)!) => 8! / 4!*4! = 70
- 공간 : O(M)

### 구현

- 이전 숫자인 k-1보다 +1을 한 숫자부터 시작을 해주면 채울 수 있음

## 총 정리

|중복|순서|시간 복잡도|공간 복잡도|
|---|---|--------|--------|
|YES|YES|O(N^M)  |O(M)    |
|NO |YES|O(N!/(N - M)!)|O(M)|
|YES|NO |O(N^M)보단 작음  |O(M)|
|NO |NO |O(N!/M!(N - M)!)|O(M)|

- 완전 탐색 문제를 접근할 때는,
  - 고를 수 있는 값의 종류 파악하기
  - 중복을 허용하는지
  - 순서가 중요한지
