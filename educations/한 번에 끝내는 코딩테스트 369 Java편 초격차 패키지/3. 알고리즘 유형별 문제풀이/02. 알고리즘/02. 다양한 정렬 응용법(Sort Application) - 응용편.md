# 정렬 - 응용편

## 수열 정렬

난이도 : 2
N <= 50

- A라는 수열이 주어짐
- A의 0번지 원소가 P의 0번지 원소를 이용하여 B의 인덱스 번호로 이동

### 문제 파악하기 -정답의 최대치

출력 : 0 ~ N - 1
N <= 50
int 범위면 충분

[수열 정렬](https://www.acmicpc.net/problem/1015)

### 접근 - 가장 쉬운 방법 O(N^2)

- 배열 정렬
  - 정렬은 O(N log N)
- P 배열 구하기
  - 순서대로 채우면 O(N)
- 복잡도
  - 시간 : O(N log N)
  - 공간 : O(N)

### 구현 스케치

```java
static class Elem implements Comparable<Elem> {
  public int num, idx;

  @Override
  public int compareTo(Elem other) {
    // TODO
    // 정렬 조건에 맞게 정렬하기
    // 1. num의 비내림차순
    // 2. num이 같으면 idx 오름차순
  }
}

static void pro() {
  // TODO: B 배열 정렬하기

  // TODO: B 배열의 값을 이용해서 P 배열 채우기

  // TODO: P 배열 출력하기
}
```

## 카드

난이도 : 1.5
N <= 100,000
-2^62 <= 카드숫자 <= 2^62
가장 많이 등장하는 숫자가 나오는 숫자 출력

[카드](https://www.acmicpc.net/problem/11652)

### 문제 파악하기 - 정답의 최대치

- 입출력 : -2^62 ~ 2^62
- Int 범위로는 감당이 안되니까 long을 쓰자!

### 접근 - 가장 쉬운 방법 O(N^2)

- 각 배열의 등장하는 숫자가 몇번 등장하는지 세는 방법
  - 첫번째 숫자 선택한 후 몇번 등장하는지 기록
  - 모든 카드의 반복 행위

### 접근 - 같은 숫자를 빨리 보는 방법 O(N log N)

- 같은 정보들은 인접해 있을 것이다 => 정렬
- Current Count : 지금 보고 있는 숫자가 등장한 횟수
- Mode Count : 지금까지의 최빈값의 등장 횟수
- Mode : 지금까지의 최빈값

### 시간, 공간 복잡도 계산하기

- 배열 정렬
  - 정렬은 O(N log N)
- Counting
  - 순서대로 읽으면 O(N)
- 복잡도
  - 시간 : O(N log N)
  - 공간 : O(N)

### 연습 문제

- BOJ 20291 - 파일 정리

## 화살표 그리기

난이도 : 2
- 점의 개수 N <= 5,000
- 0 <= 점의 위치 <= 10^5 = 100,000
- 1 <= 점의 색깔 <= N

[화살표 그리기](https://www.acmicpc.net/problem/15970)

### 문제 파악하기 - 정답의 최대치

N = 5,000
점 두 개 => 2 * 10^5만큼의 화살표 길이
색깔마다 이런 점들이 있다면? 총 5,000/2 쌍 만큼 만들 수 있다.
즉, 모든 점마다 10만 만큼의 길이를 갖는 화살표를 그리는 경우 이므로 정답의 최대치: 5,000 * 100,000 = 5 * 10^8
=> Integer 로 계산해도 충분하겠구나!

### 접근 - 가장 쉬운 방법 O(N^2)

O(N) * N = O(N^2)
100억 > 1초

### 접근 - 각 점마다, 자신과 가장 가까운 점을 빨리 찾기 O(N log N)

1. 같은 색깔의 점들만 모아서 보자
  - 색깔마다 ArrayList를 만들어주면, 총 배열의 크기는 O(N) 이다.
2. 모은 뒤에, 각 점마다 자신과 가장 가까운 것을 찾아야 한다.
3. 정렬의 특성을 이용하기 위해 점들의 위치를 오름차순 정렬한다. O(N log N)

### 시간, 공간 복잡도 계산하기

1. 색깔별로 모으기
  - 공간 : ArrayList로 O(N)
2. 배열 정렬
  - 정렬은 O(N log N)
3. 정답 계산
  - 점마다 좌우만 보니까 O(N)만큼 걸린다
4. 복잡도
  - 시간 : O(N log N)
  - 공간 : O(N)

### 구현 스케치
