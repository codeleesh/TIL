# 정렬 - 응용편

## 수열 정렬

난이도 : 2
N <= 50

- A라는 수열이 주어짐
- A의 0번지 원소가 P의 0번지 원소를 이용하여 B의 인덱스 번호로 이동

### 문제 파악하기 -정답의 최대치

출력 : 0 ~ N - 1
N <= 50
int 범위면 충분

### 접근 - 가장 쉬운 방법 O(N^2)

- 배열 정렬
  - 정렬은 O(N log N)
- P 배열 구하기
  - 순서대로 채우면 O(N)
- 복잡도
  - 시간 : O(N log N)
  - 공간 : O(N)

### 구현 스케치

```java
static class Elem implements Comparable<Elem> {
  public int num, idx;

  @Override
  public int compareTo(Elem other) {
    // TODO
    // 정렬 조건에 맞게 정렬하기
    // 1. num의 비내림차순
    // 2. num이 같으면 idx 오름차순
  }
}

static void pro() {
  // TODO: B 배열 정렬하기

  // TODO: B 배열의 값을 이용해서 P 배열 채우기

  // TODO: P 배열 출력하기
}
```

## 카드

난이도 : 1.5
N <= 100,000
-2^62 <= 카드숫자 <= 2^62
가장 많이 등장하는 숫자가 나오는 숫자 출력

[카드](https://www.acmicpc.net/problem/11652)

### 문제 파악하기 - 정답의 최대치

- 입출력 : -2^62 ~ 2^62
- Int 범위로는 감당이 안되니까 long을 쓰자!

### 접근 - 가장 쉬운 방법 O(N^2)

- 각 배열의 등장하는 숫자가 몇번 등장하는지 세는 방법
  - 첫번째 숫자 선택한 후 몇번 등장하는지 기록
  - 모든 카드의 반복 행위

### 접근 - 같은 숫자를 빨리 보는 방법 O(N log N)

- 같은 정보들은 인접해 있을 것이다 => 정렬
- Current Count : 지금 보고 있는 숫자가 등장한 횟수
- Mode Count : 지금까지의 최빈값의 등장 횟수
- Mode : 지금까지의 최빈값

### 시간, 공간 복잡도 계산하기

- 배열 정렬
  - 정렬은 O(N log N)
- Counting
  - 순서대로 읽으면 O(N)
- 복잡도
  - 시간 : O(N log N)
  - 공간 : O(N)

### 연습 문제

- BOJ 20291 - 파일 정리
