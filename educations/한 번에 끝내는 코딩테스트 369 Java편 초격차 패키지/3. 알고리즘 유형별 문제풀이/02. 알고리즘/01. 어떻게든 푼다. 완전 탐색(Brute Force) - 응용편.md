# 완전 탐색(Brute Force)

## 연산자 끼워넣기

- 중복없이 순서있게 나열하기
- N-1 개의 연산자
- 사칙연산 =? [+, -, X, /]
- cnt[x] := x번째 사칙연산이 몇 개 사용 가능한 지

[N과 M(3)](https://www.acmicpc.net/problem/14888)

### 문제 파악하기 - 정답의 최대치

- 출력 항상 -10억보다 크거나 같고, 10억보다 작거나 같은 결과
- int 범위 : -21억 ~ 21억 -> int 형 변수를 사용하면 된다.

### 시간, 공간 복잡도 계산하기

- 시간 : O(N! / (N-M)!) => 10! / 0!
- 공간 : O(M) -> M개의 숫자를 저장하기 때문에

### 구현 스케치

- 숫자의 개수 : N
- 정답을 기록할 최대값과 최소값 : max, min
- 숫자를 들고 있는 배열 : nums
- 각 연산자를 들고 있는 배열 : operators
- 어떤 순서로 연산자를 들고 있는 베열 : order

### 문제점

- 탐색이 완료될떄마다 For문을 통해서 Calcurator 함수를 수행
- 좀 더 빠르게 하기 위해서, 연산 결과를 같이 전달

### 구현 스케치 - 심화

- order[1...N-1] 에 연산자들이 순서대로 저장될 것
- k-1 번째 연산자까지 계산한 결과가 value
- 모든 연산자들을 전부 나열하는 방법을 찾은 상태
  - value 를 정답게 갱신
- k 번째 연산자는 무엇을 선택할 것인가?
  - 4 가지의 연산자들 중에 뭘 쓸 것인지 선택하고 연산자를 계산한 후에 재귀호출하기

## N-Queen

[N-Queen](https://www.acmicpc.net/problem/9663)

### 문제 파악하기 - 정답의 최대치

- 출력 N=14 일 때 정답? 21억을 넘는 지 모른다.
- 일단 int로 정하고 N=14를 입력으로 넣어 보고 확인하기

### 문제 접근하기

- 재귀함수를 통해 모든 위치에 퀸을 놓는 작업
- N개 중에서 중복을 허용해서
  - N개를 순서대로 나열하는 모든 경우 탐색하기

### 시간, 공간 복잡도 계산하기

- 시간 : O(N^M) => 14^14 > 10^16
- 공간 : O(M) -> M개의 숫자를 저장하기 때문에

### 구현 스케치

- 입력받는 수 : N
- 가능한 경우의 수를 셀 변수 : ans
- 어떤 열들을 놓아왔는지 기록할 배열 : col
- 재귀함수
  - row 번 ~ N 번 행에 대해서 가능한 퀸를 놓는 경우의 수 구하기

### 구현 스케치 - 심화

- 퀸을 다 놓고 valid한 check를 하는 것이 아닌 성공적으로 놓는 경우에 대해서만 재귀호출을 가능하도록 퀸을 놓으면서 체크

## 부분 수열의 합

- 목표 S = 0
- 부분 수열 : 수열의 일부 항을 선택해서 원래 수선대로 나열
- 진 부분 수열 : 아무것도 안 고르는 경우를 제외한 수열

[부분 수열의 합](https://www.acmicpc.net/problem/1182)

### 문제 파악하기 - 정답의 최대치

- N <= 20
- |S| <= 1,000,000
- |Ai| <= 1,000,000
- 부분 수열의 개수 상한 : 2^20 <= 1,048,576 -> 정답 변수는 int 형 변수를 쓰면 된다!
- 부분 수열의 합 상한 : 20 * 1,000,000 -> 합을 기록하는 변수는 int 형 변수를 쓰면 된다!

### 시간, 공간 복잡도 계산하기

- 0 or 1
- 0 : 부분 수열에 포함시키지 않는다.
- 1 : 부분 수열에 포함시킨다.
- 0 또는 1을 N번 나열 => 중복, 순서
- 시간 : O(N^M) = 2^20
- 공간 : O(M)

### 구현 스케치

- 입력값 : N
- 목표값 : S
- 정답을 기록한 배열 : ans
- 입력 배열 : nums
- 재귀함수
  - k번째 원소를 포함시킬지 정하는 함수
  - value는 k-1 번째 원소까지 골라진 원소들의 합

## 재귀 함수를 이용한 완전 탐색(Brute Force)

- 백준의 알고리즘 분류 - 백트래킹
- 백트래킹 정의
  - 재귀 함수의 정의
