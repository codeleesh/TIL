# 트리(Tree)

Tree := V + E + 다음의 특성 (2개 이상 만족)

1. 모두가 연결되어 있는 그래프
  -> 어떤 두 점을 골라도 간선을 타고 사이를 이동 가능
2. 사이클이 존재하지 않음
3. 정점 개수 |V| = 간선 개수 |E| + 1

## Rooted Tree

- Node : Vertex
- Root :
- Depth : 깊이, Root로부터의 길이, 상대적인 값이므로 1부터 시작해도 상관없다.
- Parent : 부모
- Child : 자식
- Ancestor : 조상
- Sibling : 같은 부모를 갖는 관계
- Leaf Node : 자식이 없는 노드

## 트리문제의 Keyword

- 즉 모든 두 정점 사이에 이들을 잇는 경로가 존재하면서 사이클이 존재하지 않는 경우만 고려한다.
- 즉 마을과 마을 사이를 직접 잇는 N-1개의 길이 있으며, 모든 마을은 연결되어 있다.
- 문제는 일반적인 그래프가 아니라 트리(연결되어 있고 사이클이 없는 그래프)

## 트리를 저장하는 방법

그래프를 저장하는 대표적인 두 가지 방법
- 인접 리스트

트리는 대부분 인접 리스트

## 트리 문제의 핵심

- 정점(Vertex) & 간선(Edge)에 대한 정확한 정의
- 트리의 요소와 문제의 요구 사항 매치

## 트리의 부모 찾기

난이도: 2
1 <= 정점 개수, N <= 100,000

[트리의 부모 찾기](https://www.acmicpc.net/problem/11725)

루트 없는 트리가 주어진다. 이때, 트리의 루트를 1이라고 정했을 때, 각 노드의 부모를 구하는 프로그램을 작성하시오.

### 접근 - Non-Rooted Tree -> Rooted Tree

1. 인접 리스트로 저장하기
2. ROOT 말고는 아무것도 정답을 구하지 못한 상태로 시작
3. 정점 X가 Parent를 안다면, 자신의 자식 Children 을 찾을 수 있다.
  1. 어떻게? 연결된 것들 중 Parent를 제외한 모든 것들!
4. ROOT부터 차례대로 문제를 해결해보자!

### 시간, 공간 복잡도 계산하기

"Root"를 시작으로 한하는 그래프 탐색 문제

탐색 알고리즘 : BFS, DFS
-> 인접 리스트를 쓴다면 O(V + E)

-> DFS가 매우 쉽게 구현할 수 있다.

### 연습 문제

- BOJ 1991 - 트리 순회
- BOJ 5639 - 이진 검색 트리
- BOJ 15900 - 나무 탈출
- BOJ 20364 - 부동산 다툼
- BOJ 3584 - 노드 사이의 거리
- BOJ 9489 - 사

## 트리

난이도: 2
1 <= 정점 개수, N <= 50

[트리의 부모 찾기](https://www.acmicpc.net/problem/1068)

단말 노드의 개수

### 정답의 최대치

단말 노드의 갯수 <= 전체 정점의 개수 <= N
Integer 범위 안에 들어온다

### 접근 - 1. 정점 제거 방법

1. 정점 X 가 지워진다.
  -> 그래프에서 정점이 사라진다?
  -> 정점과 이러진 간선들이 모두 사라진다.
  -> 정점 X의 부모에서 X로 가는 간선을 삭제 or 무시하자!
2. 트리의 단말 노드의 개수?
  -> 트리 := Root 노드와 연결된 정점들의 그래프
  -> 트리의 단말 노드 := Root 노드에서 탐색할 수 있는 단말 노드의 개수
  -> Root를 시작점으로 하는 그래프 탐색 알고리즘! BFS or DFS
  -> 이렇게 문제를 풀어도 된다.

### 접근 - 트리에서의 큰 문제와 작은 문제

새로운 용어 : Subtree

Rooted tree에서 어떤 정점 X의 Subtree란?

X와 그의 모든 자손들을 포함하는 트리! -> X가 새로운 Root가 된다.

### 접근 - 트리에서의 큰 문제와 작은 문제

큰 문제와 작은 문제

큰 문제 := 트리 안에 있는 단말 노드의 개수
작은 문제 := Root의 자식 노드들의 subtree 안에 있는 단말 노드의 개수

<포인트>

큰 문제의 정답을 작은 문제의 정답을 이용해서 구하자!

### 접근 - 3. 단말 노드의 개수를 세는 법

leaf[x] := x를 root로 하는 subtree에 있는 단말 노드의 개수
- x가 단말 노드인 경우 -> leaf[x] = 1
- 아닌 경우 -> x의 자식들에 대해 leaf를 먼저 계산한다면?
          -> leaf[x] = leaf[x의 자식 노드들]

<leaf[x]를 계산하는 방법>

Root에서 DFS를 한다면?

어떤 노드 X에서 자식 노드 Y에 대한 탐색을 끝내고 돌아오면 leaf[Y] 값이 계산되어 왔을 테니, leaf[X] 에 leaf[Y] 를 누적해주면 된다

### 시간, 공간 복잡도 계산하기

"Root"를 시작으로 하는 그래프 탐색 문제

탐색 알고리즘 : BFS or DFS
-> 인접 리스트를 쓴다면 O(V + E)

-> DFS 가 매우 쉽게 구현할 수 있다!

### 연습 문제

- BOJ 15681 - 트리와 쿼리
- BOJ 14267 - 회사 문화 1
